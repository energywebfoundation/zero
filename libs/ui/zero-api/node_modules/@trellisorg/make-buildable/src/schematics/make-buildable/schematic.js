"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const check_project_exists_1 = require("@nrwl/workspace/src/utils/rules/check-project-exists");
const workspace_1 = require("@nrwl/workspace");
const merge = require("lodash.merge");
const parseVersionRegex = /\d+\.\d+\.\d+/;
function getVersions(host) {
    var _a, _b;
    const packageJson = workspace_1.readJsonInTree(host, 'package.json');
    const nrwlWorkspace = packageJson.devDependencies['@nrwl/workspace'].match(parseVersionRegex)[0];
    const angular = (_a = packageJson.dependencies['@angular/core']) === null || _a === void 0 ? void 0 : _a.match(parseVersionRegex)[0];
    const tsLib = (_b = packageJson.dependencies['tslib']) === null || _b === void 0 ? void 0 : _b.match(parseVersionRegex)[0];
    return {
        angular,
        tsLib,
        nx: parseInt(nrwlWorkspace.split('.')[0]),
    };
}
function createAngularBuildTarget(projectName, root, configurations, nxVersion) {
    return {
        builder: nxVersion >= 11
            ? '@nrwl/angular:ng-packagr-lite'
            : '@nrwl/angular:package',
        options: {
            tsConfig: `${root}/tsconfig.lib.json`,
            project: `${root}/ng-package.json`,
        },
        configurations: configurations.reduce((prev, cur) => (Object.assign(Object.assign({}, prev), { [cur]: { tsConfig: `${root}/tsconfig.lib.prod.json` } })), {}),
    };
}
function createNodeBuildTarget(projectName, root) {
    return {
        builder: '@nrwl/node:package',
        options: {
            outputPath: `dist/${root}`,
            tsConfig: `${root}/tsconfig.lib.json`,
            packageJson: `${root}/package.json`,
            main: `${root}/src/index.ts`,
            assets: [`${root}/*.md`],
        },
    };
}
function normalizeOptions(options, workspace, versions, npmScope) {
    const project = workspace.projects[options.projectName];
    const projectRoot = project.root;
    return Object.assign(Object.assign({}, options), { projectRoot, offsetFromRoot: workspace_1.offsetFromRoot(projectRoot), isAngular: options.libType === 'angular', configurations: (options.configs || '')
            .trim()
            .split(',')
            .map((config) => config.trim().toLowerCase()), pathInLibs: options.projectName.replace(/-/g, '/'), angularVersion: versions.angular, tsLibVersion: versions.tsLib, npmScope });
}
function addFiles(options) {
    return schematics_1.mergeWith(schematics_1.apply(schematics_1.url(`./files/${options.isAngular ? 'angular' : 'node'}`), [
        schematics_1.applyTemplates(options),
        schematics_1.move(options.projectRoot),
    ]));
}
function updateWorkspace(schema, nxVersion) {
    return workspace_1.updateWorkspaceInTree((workspace) => {
        const project = workspace.projects[schema.projectName];
        const isAngular = schema.libType === 'angular';
        const root = project.root;
        project.architect.build = isAngular
            ? createAngularBuildTarget(schema.projectName, root, schema.configurations, nxVersion)
            : createNodeBuildTarget(schema.projectName, root);
        return workspace;
    });
}
function updateLibTsConfigAngular(root) {
    return workspace_1.updateJsonInTree(`${root}/tsconfig.lib.json`, (json, context) => {
        json = merge({
            compilerOptions: {
                target: 'es2015',
                declaration: true,
                declarationMap: true,
                inlineSources: true,
                types: [],
                lib: ['dom', 'es2018'],
            },
            angularCompilerOptions: {
                skipTemplateCodegen: true,
                strictMetadataEmit: true,
                enableResourceInlining: true,
            },
            exclude: ['src/test-setup.ts', '**/*.spec.ts'],
            include: ['**/*.ts'],
        }, json);
        return json;
    });
}
function updateLibTsConfigNode(root) {
    return workspace_1.updateJsonInTree(`${root}/tsconfig.lib.json`, (json, context) => {
        return merge({
            compilerOptions: {
                module: 'commonjs',
                declaration: true,
                types: ['node'],
            },
            exclude: ['**/*.spec.ts'],
            include: ['**/*.ts'],
        }, json);
    });
}
function default_1(options) {
    return (host, context) => {
        const workspace = workspace_1.readWorkspace(host);
        const versions = getVersions(host);
        const npmScope = workspace_1.readNxJson().npmScope;
        const normalizedOptions = normalizeOptions(options, workspace, versions, npmScope);
        return schematics_1.chain([
            check_project_exists_1.checkProjectExists(options),
            addFiles(normalizedOptions),
            normalizedOptions.isAngular
                ? updateLibTsConfigAngular(normalizedOptions.projectRoot)
                : updateLibTsConfigNode(normalizedOptions.projectRoot),
            updateWorkspace(normalizedOptions, versions.nx),
        ]);
    };
}
exports.default = default_1;
//# sourceMappingURL=schematic.js.map